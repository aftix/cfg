inputs: lib:
lib.fix
(self: {
  # Apply a function recursively on a directory tree
  # This is a generic version of lib.packagesFromDirectoryRecursive
  applyOnDirectoryRecursive = {
    # path of entrypoint to recurse from
    directory,
    # Function to apply
    # type: path -> anything
    toApply,
    # If a directory contains a file named exactly this, the entire directory is taken as one entry
    # This means that toApply is only called once for the entire subtree, with the argument being the
    # path to the corresponding default nix file
    defaultFilename ? "default.nix",
    # Whether or not to nest subattrsets based on the directory structure
    flatten ? false,
  }: let
    inherit (lib) concatMapAttrs pathExists;
    inherit (lib.path) append;
    inherit (lib.strings) hasSuffix removeSuffix;
    defaultPath = append directory defaultFilename;
  in
    # if a default file exists, just apply the function directly
    if pathExists defaultPath
    then {
      ${builtins.baseNameOf directory} = toApply defaultPath;
    }
    else
      concatMapAttrs (
        name: type:
        # Otherwise, for each direntry
        let
          path = append directory name;
        in
          if type == "directory"
          then let
            recurse =
              # recurse into directories
              self.applyOnDirectoryRecursive {
                inherit toApply defaultFilename flatten;
                directory = path;
              };
          in
            if flatten
            then recurse
            else {
              ${name} = recurse;
            }
          else if type == "regular" && hasSuffix ".nix" name
          then {
            # Import .nix files
            ${removeSuffix ".nix" name} = toApply path;
          }
          else if type == "regular"
          then
            # ignore non-nix files
            {}
          else
            throw ''
              myLib.applyOnDirectoryRecursive: unsupported file type ${type} at path ${builtins.toString path}
            ''
      ) (builtins.readDir directory);

  # Get nixpkgs modules recursively from a directory into a flat attrset
  # if a directory includes a "default.nix" then the entire directory is treated as one module
  modulesFromDirectoryRecursive = directory:
    self.applyOnDirectoryRecursive {
      inherit directory;
      toApply = path: import path;
    };

  # Get nixos configuration entrypoints recursively from a directory into a flat attrset
  # if a directory includes a "configuration.nix" then the entire directory is treated as one module
  # Note that the entry point is named "entry.nix" and should be a function
  # such as:
  #
  # {inputs, extraArgs}:
  # { ... }
  #
  # Then the output of the function will be applied to genNixosSystem
  nixosConfigurationsFromDirectoryRecursive = {
    # Entry point for nixos configuration directory tree
    directory,
    # Generated by dependencyInjects to inject inputs into the module system
    dep-injects,
    # Special args passed to lib.nixosSystem
    specialArgs ? {},
    # If home-manager is used, this is passed to the home-manager module
    extraSpecialArgs ? {},
    # extra arguments passed to the entrypoints (just like specialArgs)
    extraArgs ? {},
  }:
    self.applyOnDirectoryRecursive {
      inherit directory;
      flatten = true;
      defaultFilename = "entry.nix";
      toApply = path: let
        args = import path (extraArgs // {inherit inputs extraArgs;});
      in
        self.genNixosSystem (args
          // {
            inherit dep-injects specialArgs extraSpecialArgs;
          });
    };

  # Generates an attrset of nixpkgs modules
  # to inject flake dependencies into configurations
  dependencyInjects = {
    extraInject ? {},
    extraHmInject ? {},
  }: {
    nixos = {lib, ...}: {
      options.dep-inject = lib.mkOption {
        type = with lib.types; attrsOf unspecified;
        default = {};
      };

      config.dep-inject =
        extraInject
        // {
          inherit inputs;
        };
    };

    home-manager = {lib, ...}: {
      options = {
        dep-inject = lib.mkOption {
          type = with lib.types; attrsOf unspecified;
          default = {};
        };
      };

      config.dep-inject =
        extraHmInject
        // {
          inherit inputs;
        };
    };

    # Inject config from nixosHomeOptions into home-manager
    # Leaves a my.nixosCfg option set to the total system configuration, and
    # recursively picks out the options defined in nixosHomeOptions and injects them into the home-manager
    # configuration so those options in particular won't need a "my.nixosCfg" before the config path.
    # Downstream users should get this from the `extra` flake output and use it to generate a hm module
    # with their sysCfg injected. The nixos side is already in the default flake nixosModule, so nothing
    # extra is needed beyond that.
    nixos-home-manager = sysCfg: {
      lib,
      pkgs,
      ...
    }: let
      homeOptions = import ./nixos-home-options.nix pkgs lib;
    in {
      options.my.nixosCfg = lib.mkOption {
        description = "The NixOS configuration";
        readOnly = true;
        type = lib.types.raw;
      };

      config = let
        inherit (lib.attrsets) mapAttrsRecursiveCond hasAttrByPath getAttrFromPath;
      in
        lib.mkMerge [
          (
            mapAttrsRecursiveCond
            # Do not recurse into attrsets that are option definitions
            (attrs: !(attrs ? "_type" && attrs._type == "option"))
            (optPath: _:
              if hasAttrByPath optPath sysCfg
              then getAttrFromPath optPath sysCfg
              else null)
            homeOptions
          )
          {
            my.nixosCfg = sysCfg;
          }
        ];
    };
  };

  # Generate a NixOS configuration with common modules applied
  # Requires an entrypoint NixOS modulee
  # Will optionally add home-manager module + users
  genNixosSystem = {
    entrypoint,
    users ? {},
    extraMods ? [],
    extraHmMods ? [],
    specialArgs ? {},
    extraSpecialArgs ? {},
    extraAttrs ? {},
    dep-injects ? {},
  }:
    lib.nixosSystem (extraAttrs
      // {
        inherit specialArgs;

        modules =
          [
            # This imports host/common
            inputs.self.nixosModules.default
            inputs.self.nixosModules.nix-settings
            (dep-injects.nixos or {})
            entrypoint
          ]
          ++ extraMods
          ++ lib.optionals (users != {}) [
            ({config, ...}: {
              home-manager = {
                useUserPackages = true;
                inherit extraSpecialArgs users;
                sharedModules =
                  [
                    # this imports home/common
                    inputs.self.homemanagerModules.default
                    ((dep-injects.nixos-home-manager or (cfg: {})) config)
                  ]
                  ++ extraHmMods;
              };
            })
          ];
      });
})
